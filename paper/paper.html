<h1
id="grepq-a-rust-application-that-quickly-filters-fastq-files-by-matching-sequences-to-a-set-of-regex-patterns">grepq:
A Rust application that quickly filters FASTQ files by matching
sequences to a set of regex patterns</h1>
<h1 id="summary">Summary</h1>
<p>Regular expressions (regex) <span class="citation"
data-cites="kleene1951representationof">(Kleene 1951)</span> have been
an important tool for finding patterns in biological codes for decades
<span class="citation" data-cites="hodgman2000historical">(Hodgman 2000
and citations therein)</span>, and unlike fuzzy-finding approaches, do
not result in approximate matches. The performance of regular
expressions can be slow, however, especially when searching for matching
patterns in large files. <em>grepq</em> is a Rust application that
quickly filters FASTQ files by matching sequences to a set of regex
patterns. <em>grepq</em> is designed with a focus on performance and
scalability. It is written in Rust, a systems programming language that
is known for its speed and safety. <em>grepq</em> is easy to install and
easy to use, with a simple command-line interface that allows users to
quickly filter large FASTQ files, and to update the order in which
patterns are matched against sequences through an in-built <em>tune</em>
command. <em>grepq</em> is open-source and available on <em>GitHub</em>
and <em>Crates.io</em>.</p>
<h1 id="statement-of-need">Statement of need</h1>
<p>The ability to quickly filter FASTQ files by matching sequences to a
set of regex patterns is an important task in bioinformatics, especially
when working with large datasets. The importance and challenge of this
task will only grow as sequencing technologies continue to advance and
produce larger and larger datasets <span class="citation"
data-cites="katz2022sequence">(Katz et al. 2022)</span>. The uses cases
of <em>grepq</em> are diverse, and include pre-processing of FASTQ files
before downstream analysis, quality control of sequencing data, and
filtering out unwanted sequences from a dataset. Where decisions need be
made quickly, such as in a clinical settings <span class="citation"
data-cites="bachurin2024structural">(Bachurin et al. 2024)</span>,
biosecurity <span class="citation"
data-cites="valdivia2012biodefense">(Valdivia-Granda 2012)</span>, and
wastewater-based epidemiology in support of public health measures <span
class="citation"
data-cites="choi2018wastewater sims2020future xylogiannopoulos2021pattern merrett2024highly">(Choi
et al. 2018; Sims and Kasprzyk-Hordern 2020; Xylogiannopoulos 2021;
Merrett et al. 2024)</span>, the ability to quickly filter FASTQ files
by matching sequences to a set of regex patterns is attractive as it
circumvents the need for more time-consuming bioinformatic
workflows.</p>
<p>Regular expressions are a powerful tool for matching sequences, but
they can be slow and inefficient when working with large datasets.
Furthermore, general purpose tools like <em>grep</em> <span
class="citation" data-cites="gnugrep">(Free Software Foundation
2023)</span> and <em>ripgrep</em> <span class="citation"
data-cites="ripgrep">(A. Gallant 2025)</span> are not optimized for the
specific task of filtering FASTQ files, and ocassionaly yield false
positives as they scan the entire FASTQ record, including the sequence
quality field. Tools such <em>awk</em> <span class="citation"
data-cites="awk">(Aho, Kernighan, and Weinberger 1988)</span> and
<em>gawk</em> <span class="citation" data-cites="gawk">(Free Software
Foundation 2024)</span> can be used to filter FASTQ files without
yielding false positives, but they are significantly slower than
<em>grepq</em> and can require the development of more complex scripts
to achieve the same result.</p>
<h1 id="implementation">Implementation</h1>
<p><em>grepq</em> is implemented in Rust, a systems programming language
known for its safety features, which help prevent common programming
errors such as null pointer dereferences and buffer overflows. These
features make Rust an ideal choice for implementing a tool like
<em>grepq</em>, which needs to be fast, efficient, and reliable.</p>
<p>Furthermore, <em>grepq</em> obtains its performance and reliability,
in part, by using the <em>seq_io</em> <span class="citation"
data-cites="seq_io">(Schlegel and Seyboldt 2025)</span> and
<em>regex</em> <span class="citation" data-cites="regex">(Gallant et al.
2025b)</span> libraries. The <em>seq_io</em> library is a well-tested
library for parsing FASTQ files, designed to be fast and efficient, and
which includes a module for parallel processing of FASTQ records through
multi-threading. The <em>regex</em> library is designed to work with
regular expressions and sets of regular expressions, and is known to be
one of the fastest regular expression libraries currently available
<span class="citation" data-cites="rebar">(Gallant et al. 2025a)</span>.
The <em>regex</em> library supports Perl-like regular expressions
without look-around or backreferences (documented at <a
href="https://docs.rs/regex/1.*/regex/#syntax"
class="uri">https://docs.rs/regex/1.*/regex/#syntax</a>).</p>
<p>Further performance gains were obtained by:</p>
<ul>
<li>use of the <em>RegexSet</em> struct from the <em>regex</em> library
to match multiple regular expressions against a sequence in a single
pass, rather than matching each regular expression individually (the
<em>RegexSet</em> is created and compiled once before entering any loop
that processes the FASTQ records, avoiding the overhead of recompiling
the regular expressions for each record)</li>
<li>multi-threading to process the records within an input FASTQ file in
parallel through use of multiple CPU cores</li>
<li>use of the <em>zlib-ng</em> backend to the <em>flate2</em> library
to read and write gzip-compressed FASTQ files, which is faster than the
default <em>miniz_oxide</em> backend</li>
<li>use of an optimised global memory allocator (the <em>mimalloc</em>
library <span class="citation" data-cites="mimalloc">(Mutiple,
n.d.)</span>) to reduce memory fragmentation and improve memory
allocation and deallocation performance</li>
<li>buffer reuse to reduce the number of memory allocations and
deallocations</li>
<li>use of byte slices to avoid the overhead of converting to and from
string types</li>
<li>in-lining of performance-critical functions</li>
<li>use of the <em>write_all</em> I/O operation that ensures the data is
written in one go, rather than writing data in smaller chunks</li>
</ul>
<h1 id="feature-set">Feature set</h1>
<p><em>grepq</em> has the following features:</p>
<ul>
<li>support for presence and absence (inverted) matching of a set of
regular expressions</li>
<li>IUPAC ambiguity code support (e.g. N, R, Y, etc.)</li>
<li>gzip support (reading and writing)</li>
<li>JSON support for pattern file input and <em>tune</em> command
output, allowing named regex sets and named regex patterns (pattern
files can also be in plain text)</li>
<li>the ability to set predicates to filter FASTQ records on the header
field (= record ID line) using a regular expression, minimum sequence
length, and minimum average quality score (supports Phred+33 and
Phred+64)</li>
<li>the ability to output matched sequences to one of four formats
(including FASTQ and FASTA)</li>
<li>the ability to tune the pattern file with the <em>tune</em> command:
this command will output a plain text or JSON file with the patterns
sorted by their frequency of occurrence in the input FASTQ file or
gzip-compressed FASTQ file (or a user-specified number of FASTQ
records). This can be useful for optimizing the pattern file for
performance, for example, by removing patterns that are rarely
matched</li>
<li>the ability to count and summarise the total number of records and
the number of matching records (or records that don’t match in the case
of inverted matching) in the input FASTQ file</li>
</ul>
<p>Other than when the <em>tune</em> command is run, a FASTQ record is
deemed to match (and hence provided in the output) when <em>any</em> of
the regex patterns in the pattern file match the sequence field of the
FASTQ record.</p>
<p>When the count option (<strong>-c</strong>) is given with the
<em>tune</em> command, <em>grepq</em> will count the number of FASTQ
records containing a sequence that is matched, for each matching regex
in the pattern file. If, however, there are multiple occurrences of a
given regex within a FASTQ record sequence field, grepq will count this
as one match. When the count option (<strong>-c</strong>) is not given
with the <em>tune</em> command, <em>grepq</em> provides the total number
of matching FASTQ records for the set of regex patterns in the pattern
file.</p>
<p>When coupled with its exceptional runtime performance (see below),
this feature set makes <em>grepq</em> a powerful and flexible tool for
filtering FASTQ records in FASTQ files. Colorized output for matching
regex patterns is not implemented to maximise speed and minimise code
complexity, but can be achieved by piping the output to <em>grep</em> or
<em>ripgrep</em> for testing purposes.</p>
<h1 id="performance">Performance</h1>
<p>The benchmarking tool <em>hyperfine</em> <span class="citation"
data-cites="Peter_hyperfine_2023">(Peter 2024)</span> was used to
compare the runtime of <em>grepq</em>, <em>fqgrep</em>, <em>seqkit</em>
<em>grep</em>, <em>ripgrep</em>, <em>awk</em>, and <em>gawk</em> for
filtering FASTQ records against a set of regular expressions. The
benchmarking was performed on a 2022 model Mac Studio with 32GB RAM and
Apple M1 max chip running macOS 15.0.1. All test and output files were
stored on and written to the internal SSD (APPLE SSD AP0512R). The
pattern file contained 30 regex patterns (see
<em>examples/16S-no-iupac.txt</em> for the patterns used, available at
<em>grepq</em>’s GitHub repository), representing the 12-mer contigs
(and their reverse compliment) listed in <strong>Table 3</strong> of
<span class="citation"
data-cites="martinez2017conserved">Martinez-Porchas et al.
(2017)</span>. The <em>awk</em> and <em>gawk</em> commands were run with
a bash script, see <em>examples/match.sh</em>, available at
<em>grepq</em>’s GitHub repository.</p>
<p>The following shows the clock times and speedup of <em>grepq</em> and
comparison tools for filtering FASTQ records against a set of regular
expressions, for a 874MB FASTQ file (SRX26365298.fastq) containing
869,034 records:</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 25%" />
<col style="width: 29%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr>
<th>tool</th>
<th>time (s)</th>
<th>× grep speedup</th>
<th>× ripgrep speedup</th>
<th>× awk speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>grepq</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fqgrep</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ripgrep</td>
<td></td>
<td>95.99</td>
<td>1.00</td>
<td>45.77</td>
</tr>
<tr>
<td>grep</td>
<td>343.64</td>
<td>1.00</td>
<td>0.01</td>
<td>0.48</td>
</tr>
<tr>
<td>awk</td>
<td>163.87</td>
<td>2.10</td>
<td>0.02</td>
<td>1.00</td>
</tr>
<tr>
<td>gawk</td>
<td>285.62</td>
<td>1.20</td>
<td>0.01</td>
<td>0.57</td>
</tr>
</tbody>
</table>
<p><em>grepq</em> v1.3.6, <em>fqgrep</em> v.1.02, <em>ripgrep</em>
v14.1.1, <em>seqkit</em> <em>grep</em> v.2.9.0, <em>grep</em>
2.6.0-FreeBSD, <em>awk</em> v. 20200816, and <em>gawk</em> v.5.3.1.</p>
<p><em>fqgrep</em> and <em>seqkit</em> <em>grep</em> were run with
default settings, <em>ripgrep</em> was run with <strong>–colors
‘match:none’ –no-line-number</strong>, and <em>grep</em> was run with
<strong>–color=never</strong>. The tools were configured to output
matching records in FASTQ format.</p>
<p>Clock times and speedup of <em>grepq</em> over <em>ripgrep</em> and
<em>grep</em> where the FASTQ file was gzip-compressed (conditions and
versions as above, but <em>grepq</em> was run with the
<strong>-x</strong> option, <em>ripgrep</em> with the
<strong>-z</strong> option, and <em>grep</em> with the
<strong>-Z</strong> option):</p>
<table>
<thead>
<tr>
<th>tool</th>
<th>time (s)</th>
<th>× grep speedup</th>
<th>× ripgrep speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>grepq</td>
<td>2.38</td>
<td>145.24</td>
<td>1.51</td>
</tr>
<tr>
<td>fqgrep</td>
<td>2.38</td>
<td>145.24</td>
<td>1.51</td>
</tr>
<tr>
<td>ripgrep</td>
<td>3.59</td>
<td>96.29</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<h1 id="testing">Testing</h1>
<p>The output of <em>grepq</em> was compared against the output of
<em>fqgrep</em>, <em>seqkit</em> <em>grep</em>, <em>ripgrep</em>,
<em>grep</em>, <em>awk</em> and <em>gawk</em>, using the <em>stat</em>
command <span class="citation" data-cites="stat">(Brown 2017)</span>,
and any difference investigated using the <em>diff</em> command <span
class="citation" data-cites="diff">(Hunt and McIlroy 2024)</span>.
Furthermore, a custom utility, <em>spikeq</em> <span class="citation"
data-cites="spikeq">(Crosbie 2024b)</span>, was developed to generate
synthetic FASTQ files with a known number of records and sequences with
user-specified lengths that were spiked with a set of regular
expressions a known number of times. This utility was used to test the
performance of <em>grepq</em> and the aforementioned tools under
controlled conditions.</p>
<p>Finally, a bash test script (see <em>examples/test.sh</em>, available
at <em>grepq</em>’s Github repository) and a simple Rust CLI
application, <em>predate</em> <span class="citation"
data-cites="predate">(Crosbie 2024a)</span>, were developed and utilised
to automate system testing, and to monitor for performance
regressions.</p>
<p><em>grepq</em> has been tested on macOS 15.0.1 (Apple M1 Max) and
Linux Ubuntu 20.04.6 LTS (AMD EPYC 7763 64-Core Processor). It may work
on other platforms, but this has not been tested.</p>
<h1 id="availability-and-documentation">Availability and
documentation</h1>
<p><em>grepq</em> is open-source and available at <em>GitHub</em> (<a
href="https://github.com/Rbfinch/grepq"
class="uri">https://github.com/Rbfinch/grepq</a>) and <em>Crates.io</em>
(<a href="https://crates.io/crates/grepq"
class="uri">https://crates.io/crates/grepq</a>).</p>
<p>Documentation and installation instructions for <em>grepq</em> is
available at the same GitHub repository, and through the
<strong>-h</strong> and <strong>–help</strong> command-line options,
which includes a list of all available commands and options, and
examples of how to use them. Example pattern files in plain text and
JSON format are also provided, as well as test scripts. <em>grepq</em>
is distributed under the MIT license.</p>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>I’m grateful to my family for their patience and support during the
development of <em>grepq</em>. I would also like to thank the developers
of the <em>seq_io</em>, <em>regex</em>, <em>mimalloc</em> and
<em>flate2</em> libraries for their excellent work, and the developers
of the <em>hyperfine</em> benchmarking tool for making it easy to
compare the performance of different tools. Finally, I would like to
thank the authors of the <em>ripgrep</em> and <em>fqgrep</em> tools for
providing inspiration for <em>grepq</em>.</p>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-awk" class="csl-entry" role="listitem">
Aho, Alfred V., Brian W. Kernighan, and Peter J. Weinberger. 1988.
<em>The AWK Programming Language</em>. <a
href="https://www.cs.princeton.edu/~bwk/btl.mirror/">https://www.cs.princeton.edu/~bwk/btl.mirror/</a>.
</div>
<div id="ref-bachurin2024structural" class="csl-entry" role="listitem">
Bachurin, Stanislav S, Mikhail V Yurushkin, Ilya A Slynko, Mikhail E
Kletskii, Oleg N Burov, and Dmitriy P Berezovskiy. 2024.
<span>“Structural Peculiarities of Tandem Repeats and Their Clinical
Significance.”</span> <em>Biochemical and Biophysical Research
Communications</em> 692: 149349.
</div>
<div id="ref-stat" class="csl-entry" role="listitem">
Brown, Andrew. 2017. <span>“<span class="nocase">stat</span>.”</span>
</div>
<div id="ref-choi2018wastewater" class="csl-entry" role="listitem">
Choi, Phil M, Ben J Tscharke, Erica Donner, Jake W O’Brien, Sharon C
Grant, Sarit L Kaserzon, Rachel Mackie, et al. 2018.
<span>“Wastewater-Based Epidemiology Biomarkers: Past, Present and
Future.”</span> <em>TrAC Trends in Analytical Chemistry</em> 105:
453–69.
</div>
<div id="ref-predate" class="csl-entry" role="listitem">
Crosbie, Nicholas D. 2024a. <span>“<span class="nocase">predate: Catch
bugs and performance regressions through automated system
testing</span>.”</span> <a
href="https://github.com/Rbfinch/predate">https://github.com/Rbfinch/predate</a>.
</div>
<div id="ref-spikeq" class="csl-entry" role="listitem">
———. 2024b. <span>“<span class="nocase">spikeq: Generates synthetic
FASTQ records free of sequences defined by regex patterns, or containing
spiked sequences based on regex patterns</span>.”</span> <a
href="https://github.com/Rbfinch/spikeq">https://github.com/Rbfinch/spikeq</a>.
</div>
<div id="ref-gnugrep" class="csl-entry" role="listitem">
Free Software Foundation. 2023. <em>GNU Grep 3.11</em>. Free Software
Foundation. <a
href="https://www.gnu.org/software/grep/manual/grep.html">https://www.gnu.org/software/grep/manual/grep.html</a>.
</div>
<div id="ref-gawk" class="csl-entry" role="listitem">
———. 2024. <em>GAWK: Effective AWK Programming: A User’s Guide for GNU
Awk, for the 5.3.1</em>. Free Software Foundation. <a
href="https://www.gnu.org/software/gawk/manual/gawk.html">https://www.gnu.org/software/gawk/manual/gawk.html</a>.
</div>
<div id="ref-rebar" class="csl-entry" role="listitem">
Gallant et al. 2025a. <span>“<span class="nocase">rebar</span>.”</span>
<a
href="https://github.com/BurntSushi/rebar">https://github.com/BurntSushi/rebar</a>.
</div>
<div id="ref-regex" class="csl-entry" role="listitem">
——— et al. 2025b. <span>“<span class="nocase">regex</span>.”</span> <a
href="https://github.com/rust-lang/regex">https://github.com/rust-lang/regex</a>.
</div>
<div id="ref-ripgrep" class="csl-entry" role="listitem">
Gallant, Andrew. 2025. <span>“Ripgrep: Recursively Search the Current
Directory for Lines Matching a Pattern.”</span> <a
href="https://github.com/BurntSushi/ripgrep">https://github.com/BurntSushi/ripgrep</a>.
</div>
<div id="ref-hodgman2000historical" class="csl-entry" role="listitem">
Hodgman, T. Charles. 2000. <span>“A Historical Perspective on
Gene/Protein Functional Assignment.”</span> <em>Bioinformatics</em> 16
(1): 10–15.
</div>
<div id="ref-diff" class="csl-entry" role="listitem">
Hunt, James W., and M. Douglas McIlroy. 2024. <span>“<span
class="nocase">diff</span>.”</span>
</div>
<div id="ref-katz2022sequence" class="csl-entry" role="listitem">
Katz, Kenneth, Oleg Shutov, Richard Lapoint, Michael Kimelman, J Rodney
Brister, and Christopher O’Sullivan. 2022. <span>“The Sequence Read
Archive: A Decade More of Explosive Growth.”</span> <em>Nucleic Acids
Research</em> 50 (D1): D387–90.
</div>
<div id="ref-kleene1951representationof" class="csl-entry"
role="listitem">
Kleene, SC. 1951. <span>“Representationof Events in Nerve Nets and
Finite Automata.”</span> <em>CE Shannon and J. McCarthy</em>.
</div>
<div id="ref-martinez2017conserved" class="csl-entry" role="listitem">
Martinez-Porchas, Marcel, Enrique Villalpando-Canchola, Luis Enrique
Ortiz Suarez, and Francisco Vargas-Albores. 2017. <span>“How Conserved
Are the Conserved 16S-rRNA Regions?”</span> <em>PeerJ</em> 5: e3036.
</div>
<div id="ref-merrett2024highly" class="csl-entry" role="listitem">
Merrett, James E, Monica Nolan, Leon Hartman, Nijoy John, Brianna Flynn,
Louise Baker, Christelle Schang, et al. 2024. <span>“Highly Sensitive
Wastewater Surveillance of SARS-CoV-2 Variants by Targeted
Next-Generation Amplicon Sequencing Provides Early Warning of Incursion
in Victoria, Australia.”</span> <em>Applied and Environmental
Microbiology</em> 90 (8): e01497–23.
</div>
<div id="ref-mimalloc" class="csl-entry" role="listitem">
Mutiple. n.d. <span>“Mimalloc: A Rust Wrapper over Microsoft’s MiMalloc
Memory Allocator.”</span>
</div>
<div id="ref-Peter_hyperfine_2023" class="csl-entry" role="listitem">
Peter, David. 2024. <span>“<span class="nocase">hyperfine: A
command-line benchmarking tool</span>.”</span> <a
href="https://github.com/sharkdp/hyperfine">https://github.com/sharkdp/hyperfine</a>.
</div>
<div id="ref-seq_io" class="csl-entry" role="listitem">
Schlegel, Markus, and Adrian Seyboldt. 2025. <span>“<span
class="nocase">seq_io: FASTA and FASTQ parsing and writing in
Rust</span>.”</span> <a
href="https://github.com/markschl/seq_io">https://github.com/markschl/seq_io</a>.
</div>
<div id="ref-sims2020future" class="csl-entry" role="listitem">
Sims, Natalie, and Barbara Kasprzyk-Hordern. 2020. <span>“Future
Perspectives of Wastewater-Based Epidemiology: Monitoring Infectious
Disease Spread and Resistance to the Community Level.”</span>
<em>Environment International</em> 139: 105689.
</div>
<div id="ref-valdivia2012biodefense" class="csl-entry" role="listitem">
Valdivia-Granda, Willy A. 2012. <span>“Biodefense Oriented Genomic-Based
Pathogen Classification Systems: Challenges and Opportunities.”</span>
<em>Journal of Bioterrorism &amp; Biodefense</em> 3 (1): 1000113.
</div>
<div id="ref-xylogiannopoulos2021pattern" class="csl-entry"
role="listitem">
Xylogiannopoulos, Konstantinos F. 2021. <span>“Pattern Detection in
Multiple Genome Sequences with Applications: The Case of All SARS-CoV-2
Complete Variants.”</span> <em>bioRxiv</em>, 2021–04.
</div>
</div>
