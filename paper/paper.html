<h1
id="grepq-a-rust-application-that-quickly-filters-fastq-files-by-matching-sequences-to-a-set-of-regex-patterns">grepq:
A Rust application that quickly filters FASTQ files by matching
sequences to a set of regex patterns</h1>
<h1 id="summary">Summary</h1>
<p>Regular expressions <span class="citation"
data-cites="kleene1951representationof">(Kleene 1951)</span> have been
an important tool for finding patterns in biological codes for decades
<span class="citation" data-cites="hodgman2000historical">(Hodgman 2000
and citations therein)</span>. However, the performance of regular
expressions can be slow, especially when matching large datasets.
<strong>grepq</strong> is a Rust application that quickly filters FASTQ
files by matching sequences to a set of regex patterns.
<strong>grepq</strong> is designed to be fast and efficient, with a
focus on performance and scalability. It is written in Rust, a systems
programming language that is known for its speed and safety.
<strong>grepq</strong> is designed to be easy to use, with a simple
command-line interface that allows users to quickly filter large FASTQ
files, and to update the order in which patterns are matched against
sequences through an in-built <code>tune</code> command.
<strong>grepq</strong> is open-source and available on GitHub.</p>
<h1 id="statement-of-need">Statement of need</h1>
<p>The ability to quickly filter FASTQ files by matching sequences to a
set of regex patterns is an important task in bioinformatics, especially
when working with large datasets. The importance and challenge of this
task will only grow as sequencing technologies continue to advance and
produce larger and larger datasets. The uses cases are diverse, and
include pre-processing of FASTQ files before downstream analysis,
quality control of sequencing data, and filtering out unwanted sequences
from a dataset. Where decisions need be made quickly, such as in a
clinical settings <span class="citation"
data-cites="bachurin2024structural">(Bachurin et al. 2024)</span>,
biosecurity <span class="citation"
data-cites="valdivia2012biodefense">(Valdivia-Granda 2012)</span>, and
wastewater-based epidemiology in support of public health measures <span
class="citation"
data-cites="choi2018wastewater sims2020future xylogiannopoulos2021pattern">(Choi
et al. 2018; Sims and Kasprzyk-Hordern 2020; Xylogiannopoulos
2021)</span>, the ability to quickly filter FASTQ files by matching
sequences to a set of regex patterns is attractive as it circumvents the
need for more time-consuming bioinformatic workflows.</p>
<p>Regular expressions are a powerful tool for matching sequences, but
they can be slow and inefficient when working with large datasets.
Furthermore, general purpose tools like <strong>grep</strong> <span
class="citation" data-cites="gnugrep">(Free Software Foundation
2023)</span> and <strong>ripgrep</strong> <span class="citation"
data-cites="ripgrep">(A. Gallant 2025)</span> are not optimized for the
specific task of filtering FASTQ files, and ocassionaly yield false
positives as they scan the entire FASTQ record. Tools such
<strong>awk</strong> <span class="citation" data-cites="awk">(Aho,
Kernighan, and Weinberger 1988)</span> and <strong>gawk</strong> <span
class="citation" data-cites="gawk">(Free Software Foundation
2024)</span> can be used to filter FASTQ files without yielding false
positives, but they are significantly slower than <strong>grepq</strong>
and can require the development of more complex scripts to achieve the
same result.</p>
<h1 id="implementation">Implementation</h1>
<p><strong>grepq</strong> is implemented in Rust, a systems programming
language that is known for its speed and safety. Rust is a modern
language that is designed to be fast and efficient, with a focus on
performance and scalability. Rust is also known for its safety features,
which help prevent common programming errors such as null pointer
dereferences and buffer overflows. These features make Rust an ideal
choice for implementing a tool like <strong>grepq</strong>, which needs
to be fast, efficient, and reliable.</p>
<p><strong>grepq</strong> obtains its performance and reliability, in
part, by using the <strong>seq_io</strong> <span class="citation"
data-cites="seq_io">(Schlegel and Seyboldt 2025)</span> and
<strong>regex</strong> <span class="citation"
data-cites="regex">(Gallant et al. 2025b)</span> Rust libraries. The
<strong>seq_io</strong> library is a well-tested library for reading and
writing FASTA and FASTQ files, designed to be fast and efficient, and
which includes a module for parallel processing through multi-threading.
The <strong>regex</strong> library is designed to work with regular
expressions and sets of regular expressions, and is known to be one of
the fastest regular expression libraries currently available <span
class="citation" data-cites="rebar">(Gallant et al. 2025a)</span>. The
<strong>regex</strong> library supports Perl-like regular expressions
without look-around or backreferences (documented at <a
href="https://docs.rs/regex/1.*/regex/#syntax"
class="uri">https://docs.rs/regex/1.*/regex/#syntax</a>).</p>
<p>By leveraging these libraries, <strong>grepq</strong> is able to
quickly filter FASTQ files by matching sequences to a set of regex
patterns, while maintaining high performance and reliability.</p>
<p>Further performance gains were obtained by:</p>
<ul>
<li>use of the <code>RegexSet</code> struct from the
<strong>regex</strong> library to match multiple regular expressions
against a sequence in a single pass, rather than matching each regular
expression individually (the <code>RegexSet</code> is created and
compiled once before entering any loop that processes the FASTQ records,
avoiding the overhead of recompiling the regular expressions for each
record)</li>
<li>multi-threading to process the records within an input FASTQ file in
parallel through use of multiple CPU cores</li>
<li>use of an optimised global memory allocator (the
<strong>mimalloc</strong> library <span class="citation"
data-cites="mimalloc">(Mutiple, n.d.)</span>) to reduce memory
fragmentation and improve memory allocation and deallocation
performance</li>
<li>buffer reuse to reduce memory allocations and deallocations</li>
<li>use of byte slices to avoid the overhead of converting to and from
string types</li>
<li>inlining of performance-critical functions</li>
<li>use of the <code>write_all</code> I/O operation that ensures the
data is written in one go, rather than writing data in smaller
chunks</li>
</ul>
<h1 id="feature-set">Feature set</h1>
<p><strong>grepq</strong> has the following features:</p>
<ul>
<li>support for presence and absence (inverted) matching of a set of
regular expressions</li>
<li>IUPAC ambiguity code support (e.g. N, R, Y, etc.)</li>
<li>gzip support (reading and writing)</li>
<li>JSON support for pattern file input and <code>tune</code> command
output, allowing named regex sets and named regex patterns (pattern
files can also be in plain text)</li>
<li>the ability to set predicates to filter FASTQ records on the header
field (= record ID line) using a regular expression, minimum sequence
length, and minimum average quality score (supports Phred+33 and
Phred+64)</li>
<li>the ability to output matched sequences to one of four formats
(including FASTQ and FASTA)</li>
<li>the ability to tune the pattern file with the <code>tune</code>
command: this command will output a plain text or JSON file with the
patterns sorted by their frequency of occurrence in the input FASTQ file
or gzip-compressed FASTQ file (or a user-specified number of FASTQ
records). This can be useful for optimizing the pattern file for
performance, for example, by removing patterns that are rarely
matched</li>
<li>the ability to count and summarise the total number of records and
the number of matching records (or records that don’t match in the case
of inverted matching) in the input FASTQ file</li>
</ul>
<p>When coupled with its excellent runtime performance (see below), this
feature set makes <strong>grepq</strong> a powerful and flexible tool
for filtering FASTQ files by matching sequences to a set of regex
patterns. Colorized output of for matching regex patterns is not
implemented to maximise speed and minimise code complexity, but can be
achieved by piping the output to <strong>grep</strong> or
<strong>ripgrep</strong> for testing purposes.</p>
<h1 id="performance">Performance</h1>
<p>The benchmarking tool <strong>hyperfine</strong> <span
class="citation" data-cites="Peter_hyperfine_2023">(Peter 2024)</span>
was used to compare the runtime of <strong>grepq</strong>,
<strong>fqgrep</strong>, <strong>ripgrep</strong>,
<strong>fqgrep</strong>, <strong>awk</strong>, and <strong>gawk</strong>
for filtering FASTQ records against a set of regular expressions. The
benchmarking was performed on a 2022 model Mac Studio with 32GB RAM and
Apple M1 max chip running macOS 15.0.1. The FASTQ file
(SRX26365298.fastq) was 874MB in size and was stored on the internal SSD
(APPLE SSD AP0512R). The pattern file contained 30 regex patterns (see
<code>examples/16S-no-iupac.txt</code> for the patterns used). The
<strong>awk</strong> and <strong>gawk</strong> commands were run with a
bash script, see <code>examples/match.sh</code>.</p>
<p>The following shows the speedup of <strong>grepq</strong> for
filtering FASTQ records against a set of regular expressions, for a
874MB FASTQ file (SRX26365298.fastq) containing 869034 records:</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 25%" />
<col style="width: 29%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr>
<th>tool</th>
<th>time (s)</th>
<th>× grep speedup</th>
<th>× ripgrep speedup</th>
<th>× awk speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>grepq</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fqgrep</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ripgrep</td>
<td></td>
<td>95.99</td>
<td>1.00</td>
<td>45.77</td>
</tr>
<tr>
<td>grep</td>
<td>343.64</td>
<td>1.00</td>
<td>0.01</td>
<td>0.48</td>
</tr>
<tr>
<td>awk</td>
<td>163.87</td>
<td>2.10</td>
<td>0.02</td>
<td>1.00</td>
</tr>
<tr>
<td>gawk</td>
<td>285.62</td>
<td>1.20</td>
<td>0.01</td>
<td>0.57</td>
</tr>
</tbody>
</table>
<p>(<strong>grepq</strong> v1.3.5, <strong>fqgrep</strong> v.1.02,
<strong>ripgrep</strong> v14.1.1, <strong>grep</strong> 2.6.0-FreeBSD,
<strong>awk</strong> v. 20200816, and <strong>gawk</strong> v.5.3.1.
<strong>ripgrep</strong> was run with –colors ‘match:none’
–no-line-number, and <strong>grep</strong> was run with
–color=never)</p>
<p>Speedup of <strong>grepq</strong> over <strong>ripgrep</strong> and
<strong>grep</strong> for filtering FASTQ records against a set of
regular expressions, where the FASTQ file was gzip-compressed:</p>
<table>
<thead>
<tr>
<th>tool</th>
<th>time (s)</th>
<th>× grep speedup</th>
<th>× ripgrep speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>grepq</td>
<td>2.38</td>
<td>145.24</td>
<td>1.51</td>
</tr>
<tr>
<td>fqgrep</td>
<td>2.38</td>
<td>145.24</td>
<td>1.51</td>
</tr>
<tr>
<td>ripgrep</td>
<td>3.59</td>
<td>96.29</td>
<td>1.00</td>
</tr>
</tbody>
</table>
<details>
<summary>
Details
</summary>
<p>
Conditions and versions as above, but the FASTQ file was
gzip-compressed. <strong>grepq</strong> was run with the <code>-x</code>
option, <strong>ripgrep</strong> with the <code>-z</code> option, and
<strong>grep</strong> with the <code>-Z</code> option.
</p>
</details>
<h1 id="testing">Testing</h1>
<p>The output of <strong>grepq</strong> was compared against the output
of output of <strong>fqgrep</strong>, <strong>ripgrep</strong>,
<strong>grep</strong>, <strong>awk</strong> and <strong>gawk</strong>,
using the <strong>stat</strong> command <span class="citation"
data-cites="stat">(Brown 2017)</span>, and any difference investigated
using the <strong>diff</strong> command <span class="citation"
data-cites="diff">(Hunt and McIlroy 2024)</span>. Furthermore, a custom
utility, <strong>spikeq</strong> <span class="citation"
data-cites="spikeq">(Crosbie 2024b)</span> was developed to generate
synthetic FASTQ files with a known number of records and sequences that
match a set of regular expressions. This utility was used to test the
performance of <strong>grepq</strong> and other tools under different
conditions, such as the number of records and sequences that match the
regular expressions.</p>
<p>Finally, a bash test script (<code>examples/test.sh</code>) and a
simple Rust CLI application, <strong>predate</strong> <span
class="citation" data-cites="predate">(Crosbie 2024a)</span>, were
developed and utilised to automate system testing, and to monitor for
performance regressions.</p>
<p><strong>grepq</strong> has been tested on macOS 15.0.1 (Apple M1 Max)
and Linux Ubuntu 20.04.6 LTS (AMD EPYC 7763 64-Core Processor). It may
work on other platforms, but this has not been tested.</p>
<h1 id="availability-and-documentation">Availability and
documentation</h1>
<p><strong>grepq</strong> is open-source and available on GitHub at: <a
href="https://github.com/Rbfinch/grepq"
class="uri">https://github.com/Rbfinch/grepq</a></p>
<p>Documentation for <strong>grepq</strong> is available at the same
GitHub repository, and through the <code>-h</code> and
<code>--help</code> command-line options, which includes a list of all
available commands and options, and examples of how to use them, as well
as a large number of examples in the <code>examples</code> directory.
Example pattern files are also provided in the <code>examples</code>
directory. <strong>grepq</strong> is distributed under the MIT
license.</p>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>I’m grateful to my family for their patience and support during the
development of <strong>grepq</strong>. I would also like to thank the
developers of the <strong>seq_io</strong> and <strong>regex</strong>
Rust libraries for their excellent work, and the developers of the
<code>hyperfine</code> benchmarking tool for making it easy to compare
the performance of different tools.</p>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-awk" class="csl-entry" role="listitem">
Aho, Alfred V., Brian W. Kernighan, and Peter J. Weinberger. 1988.
<em>The AWK Programming Language</em>. <a
href="https://www.cs.princeton.edu/~bwk/btl.mirror/">https://www.cs.princeton.edu/~bwk/btl.mirror/</a>.
</div>
<div id="ref-bachurin2024structural" class="csl-entry" role="listitem">
Bachurin, Stanislav S, Mikhail V Yurushkin, Ilya A Slynko, Mikhail E
Kletskii, Oleg N Burov, and Dmitriy P Berezovskiy. 2024.
<span>“Structural Peculiarities of Tandem Repeats and Their Clinical
Significance.”</span> <em>Biochemical and Biophysical Research
Communications</em> 692: 149349.
</div>
<div id="ref-stat" class="csl-entry" role="listitem">
Brown, Andrew. 2017. <span>“<span class="nocase">stat</span>.”</span>
</div>
<div id="ref-choi2018wastewater" class="csl-entry" role="listitem">
Choi, Phil M, Ben J Tscharke, Erica Donner, Jake W O’Brien, Sharon C
Grant, Sarit L Kaserzon, Rachel Mackie, et al. 2018.
<span>“Wastewater-Based Epidemiology Biomarkers: Past, Present and
Future.”</span> <em>TrAC Trends in Analytical Chemistry</em> 105:
453–69.
</div>
<div id="ref-predate" class="csl-entry" role="listitem">
Crosbie, Nicholas D. 2024a. <span>“<span class="nocase">predate: Catch
bugs and performance regressions through automated system
testing</span>.”</span> <a
href="https://github.com/Rbfinch/predate">https://github.com/Rbfinch/predate</a>.
</div>
<div id="ref-spikeq" class="csl-entry" role="listitem">
———. 2024b. <span>“<span class="nocase">spikeq: Generates synthetic
FASTQ records free of sequences defined by regex patterns, or containing
spiked sequences based on regex patterns</span>.”</span> <a
href="https://github.com/Rbfinch/spikeq">https://github.com/Rbfinch/spikeq</a>.
</div>
<div id="ref-gnugrep" class="csl-entry" role="listitem">
Free Software Foundation. 2023. <em>GNU Grep 3.11</em>. Free Software
Foundation. <a
href="https://www.gnu.org/software/grep/manual/grep.html">https://www.gnu.org/software/grep/manual/grep.html</a>.
</div>
<div id="ref-gawk" class="csl-entry" role="listitem">
———. 2024. <em>GAWK: Effective AWK Programming: A User’s Guide for GNU
Awk, for the 5.3.1</em>. Free Software Foundation. <a
href="https://www.gnu.org/software/gawk/manual/gawk.html">https://www.gnu.org/software/gawk/manual/gawk.html</a>.
</div>
<div id="ref-rebar" class="csl-entry" role="listitem">
Gallant et al. 2025a. <span>“<span class="nocase">rebar</span>.”</span>
<a
href="https://github.com/BurntSushi/rebar">https://github.com/BurntSushi/rebar</a>.
</div>
<div id="ref-regex" class="csl-entry" role="listitem">
——— et al. 2025b. <span>“<span class="nocase">regex</span>.”</span> <a
href="https://github.com/rust-lang/regex">https://github.com/rust-lang/regex</a>.
</div>
<div id="ref-ripgrep" class="csl-entry" role="listitem">
Gallant, Andrew. 2025. <span>“Ripgrep: Recursively Search the Current
Directory for Lines Matching a Pattern.”</span> <a
href="https://github.com/BurntSushi/ripgrep">https://github.com/BurntSushi/ripgrep</a>.
</div>
<div id="ref-hodgman2000historical" class="csl-entry" role="listitem">
Hodgman, T. Charles. 2000. <span>“A Historical Perspective on
Gene/Protein Functional Assignment.”</span> <em>Bioinformatics</em> 16
(1): 10–15.
</div>
<div id="ref-diff" class="csl-entry" role="listitem">
Hunt, James W., and M. Douglas McIlroy. 2024. <span>“<span
class="nocase">diff</span>.”</span>
</div>
<div id="ref-kleene1951representationof" class="csl-entry"
role="listitem">
Kleene, SC. 1951. <span>“Representationof Events in Nerve Nets and
Finite Automata.”</span> <em>CE Shannon and J. McCarthy</em>.
</div>
<div id="ref-mimalloc" class="csl-entry" role="listitem">
Mutiple. n.d. <span>“Mimalloc: A Rust Wrapper over Microsoft’s MiMalloc
Memory Allocator.”</span>
</div>
<div id="ref-Peter_hyperfine_2023" class="csl-entry" role="listitem">
Peter, David. 2024. <span>“<span class="nocase">hyperfine: A
command-line benchmarking tool</span>.”</span> <a
href="https://github.com/sharkdp/hyperfine">https://github.com/sharkdp/hyperfine</a>.
</div>
<div id="ref-seq_io" class="csl-entry" role="listitem">
Schlegel, Markus, and Adrian Seyboldt. 2025. <span>“<span
class="nocase">seq_io: FASTA and FASTQ parsing and writing in
Rust</span>.”</span> <a
href="https://github.com/markschl/seq_io">https://github.com/markschl/seq_io</a>.
</div>
<div id="ref-sims2020future" class="csl-entry" role="listitem">
Sims, Natalie, and Barbara Kasprzyk-Hordern. 2020. <span>“Future
Perspectives of Wastewater-Based Epidemiology: Monitoring Infectious
Disease Spread and Resistance to the Community Level.”</span>
<em>Environment International</em> 139: 105689.
</div>
<div id="ref-valdivia2012biodefense" class="csl-entry" role="listitem">
Valdivia-Granda, Willy A. 2012. <span>“Biodefense Oriented Genomic-Based
Pathogen Classification Systems: Challenges and Opportunities.”</span>
<em>Journal of Bioterrorism &amp; Biodefense</em> 3 (1): 1000113.
</div>
<div id="ref-xylogiannopoulos2021pattern" class="csl-entry"
role="listitem">
Xylogiannopoulos, Konstantinos F. 2021. <span>“Pattern Detection in
Multiple Genome Sequences with Applications: The Case of All SARS-CoV-2
Complete Variants.”</span> <em>bioRxiv</em>, 2021–04.
</div>
</div>
